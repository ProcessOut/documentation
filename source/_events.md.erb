## Events

When a transaction receives an update (such as when its state changes from
pending to completed, or if the transaction gets reversed), ProcessOut creates
an event which can be fetched and processed by your application.

ProcessOut may also fire events not directly related to a transaction, such as
when the project gets updated. Such events may also be catched.

##### Attributes
|||
--:|:--
**id**<br />*string*<br />Read-only |
**name**<br />*string*<br />Read-only | Name of the event corresponding to the action
**data**<br />*json object*<br />Read-only | Data linked to the event
**date**<br />*timestamp*<br />Read-only |
**sandbox**<br />*boolean*<br />Read-only |

### Polling events

```javascript
var events = ProcessOut.Event.pull();
for (var i = 0; i < events.length; i++)
{
    var event = events[i];
    var data  = event.getData();
    // Do stuff on the event with its data

    // Once you're done with the event, you may mark it
    // as processed so that pull() won't return it anymore.
    event.markProcessed();
}
```

```python
from processout.event import Event

events = Event.pull()
for event in events:
    var data = event.data
    # Do stuff on the event with its data

    # Once you're done with the event, you may mark it
    # as processed so that pull() won't return it anymore.
    event.markProcessed()
```

```php
<?php
$events = ProcessOut\Event::pull();
foreach($events as $event)
{
    $data = $event->getData();
    // Do stuff on the event with its data

    // Once you're done with the event, you may mark it
    // as processed so that pull() won't return it anymore.
    $event->markProcessed();
}
?>
```

Events can be fetched using the API, and behave as a queue
(first in, first out). This means that you always get the first not-processed
event. Once an event is marked as processed, it will not be listed by the API
anymore. Simply fetching an event from ProcessOut will **not** mark an event
as processed, it needs to be marked as so explicitely.

One could imagine setting up a background worker fetching events
from ProcessOut to synchronously fetch new events


### Find an event

```javascript
// Find a specific not-processed event by its id
var event = ProcessOut.Event.find('<event-id>');
```

```python
# Find a specific not-processed event by its id
event = Event.find('<event-id>')
```

```php
<?php
// Find a specific not-processed event by its id
$event = ProcessOut\Event::find('<event-id>');
?>
```

It also possible to fetch a specific event thanks to its `id`.

#### What's next?

- [Mark an event as processed](#process-an-event)
- [Set up webhooks](#webhooks)


### Process an event

```javascript
// Mark an event as processed once done with it
event.markProcessed();
```

```python
# Mark an event as processed once done with it
event.markProcessed()
```

```php
<?php
// Mark an event as processed once done with it
$event->markProcessed();
?>
```

Once an event was successfully processed by your application, you'll have to
mark it as `processed`. If an event is not marked as such, polling events
will always return the same events.


## Events data

### Invoice events

The different events ProcessOut currently offers are listed below. With each event
comes resources associated with it. Each event may describe different resources.

##### Events
|||
--:|:--
invoice.transaction.waiting | No payment has been placed yet <br />*Describes:* [invoice](#invoices), [transaction](#transactions), [customer](#customers)
invoice.transaction.pending | The payment is pending completion by the payment gateway <br />*Describes:* [invoice](#invoices), [transaction](#transactions), [customer](#customers)
invoice.transaction.completed | The payment was sucessfully completed <br />*Describes:* [invoice](#invoices), [transaction](#transactions), [customer](#customers)
invoice.transaction.failed | The payment has been placed, but failed <br />*Describes:* [invoice](#invoices), [transaction](#transactions), [customer](#customers)
invoice.transaction.disputed | The payment was previously completed but the customer filled a dispute <br />*Describes:* [invoice](#invoices), [transaction](#transactions), [customer](#customers)
invoice.transaction.solved | The previous dispute has been resolved in your favor <br />*Describes:* [invoice](#invoices), [transaction](#transactions), [customer](#customers)
invoice.transaction.reversed | The previous dispute has been resolved in your customer's favor <br />*Describes:* [invoice](#invoices), [transaction](#transactions), [customer](#customers)
invoice.transaction.refunded | You refunded the transaction <br />*Describes:* [invoice](#invoices), [transaction](#transactions), [customer](#customers)

### Recurring invoice events

In addition to the previous invoice events, ProcessOut also provides
events related to your recurring invoices.

*Note:* When a recurring-invoice/subscription iterates, a new invoice and its associated transaction will be marked as completed and its corresponding event will also be sent.

##### Events
|||
--:|:--
customer.recurring-invoice.started | The subscription started <br />*Describes:* [recurring-invoice](#subcriptions), [customer](#customers)
customer.recurring-invoice.iterated | The customer paid for the current iteration of its subscription <br />*Describes:* [recurring-invoice](#subscriptions), [customer](#customers)
customer.recurring-invoice.ended | The customer's subscription ended <br />*Note:* It might have ended because the payment gateway refused your customer's payment (ex: when the credit card expired) <br />*Describes:* [recurring-invoice](#subscriptions), [customer](#customers)

### Example

```json
{
    "name": "invoice.transaction.completed",
    "sandbox": false,
    "invoice": {
        "id": "00000000-0000-0000-0000-000000000000",
        "url": "https://checkout.processout.com/00000000-0000-0000-0000-000000000000",
        "project": {
          "id": "00000000-0000-0000-0000-000000000000",
          "name": "Project name",
          "logo_url": "https://company.tld/logo.png"
        },
        "customer": null,
        "name": "Awesome item",
        "price": "4.99",
        "taxes": "0.49",
        "shipping": "2.00",
        "total": "7.58",
        "currency": "USD",
        "meta": {
          "discount": "20%",
          "love": "100%"
        },
        "request_email": true,
        "request_shipping": true,
        "return_url": "https://company.tld/success",
        "cancel_url": "https://company.tld/cancel"
    },
    "transaction": {
        "id": "00000000-0000-0000-0000-000000000000",
        "status": "completed",
        "processout_fee": "0.15",
        "gateway": {
            "name": "paypal",
            "payment_id": "txn_id",
            "fee": "0.45",
            "fee_currency": "USD",
            "data": "raw data from gateway"
        }
    },
    "customer": null
}
```

The example presented on the right pane is the data contained in a
`invoice.transaction.completed` event. It is important to notice it contains
2 fields which will always be present:

- `name` and
- `sandbox`,

as well as 3 resources the event describes:

- `invoice`,
- `transaction` and
- `customer`.

In this case, no customer was linked to the invoice during the purchase, so
the customer resource is *null*.
