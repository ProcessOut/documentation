## Webhooks

Processing [events](#events) can also be done through webhooks (also called
callbacks or Instant Payment Notification: IPN). It is essentially a web
request made to your web application, posting the data related to the event.
Webhooks can be used to automatically deliver an item upon successful
payment, for instance, without the need for an application running in the
background.

However, as many payment gateways can be used at the same time, ProcessOut
provides webhooks containing unified, normalized and easy to use data, as well
as transaction states corresponding to the triggered event.

### Pre-requisites

In order to start receiving webhooks, you must add your `notify_url`s in your
[ProcessOut dashboard](https://dashboard.processout.com).

You should also note that *we will always `POST` a json encoded body request*
to your application. Therefore, you should accept POST requests with a json body.

Furthermore, you should *remove all CSRF protection* on your endpoints receiving
webhooks. Most frameworks and CMS activate it by default, which could
prevent ProcessOut from correctly posting webhooks to your application.


### Usage

```javascript
// Let's assume reqRaw is filled with the raw request content
// req is filled with the decoded json data from the request body
// and headers is filled with the request headers

// We first need to check that the webhook is coming from ProcessOut
var webhook = new ProcessOut.Webhook();
if (! webhook.validate(reqRaw, headers['ProcessOut-Signature'])) {
    console.log('Bad webhook');
    return;
}

// Then make sure the event isn't coming from the sandbox (if in production)
if ('sandbox' in req && req['sandbox']) {
    console.log('Not in sandbox env');
    return;
}

// Webhook is legit! Perform actions on it
switch (input['name']) {
case 'invoice.transaction.completed':
    // Transaction successful
    break;
case 'invoice.transaction.pending':
    // Transaction still needs some time to be processed
    break;
// ...
default:
    console.log('Unknown webhook action');
    return;
}
```

```python
from processout.webhook import Webhook

# Let's assume reqRaw is filled with the raw request content
# req is filled with the decoded json data from the request body
# and headers is filled with the request headers

# We first need to check that the webhook is coming from ProcessOut
webhook = Webhook()
if not webhook.validate(reqRaw, headers['ProcessOut-Signature']):
    print ('Bad webhook')
    return

# Webhook is legit! Perform actions on it
if req['name'] == 'invoice.transaction.completed':
    # Transaction successful
    pass

elif req['name'] == 'invoice.transaction.pending':
    # Transaction still needs some time to be processed
    pass

# ...

else:
    # Shouldn't be here..
    print('Unknown webhook action')
```

```php
<?php
$reqRaw = trim(file_get_contents('php://input'));
$req    = json_decode($reqRaw, true);

// We first need to check that the webhook is coming from ProcessOut
$webhook = new \ProcessOut\Webhook();
if (! $webhook->validate($reqRaw, $_SERVER['HTTP_ProcessOut-Signature']))
{
    echo 'Bad webhook'; exit();
}

// Then make sure the event isn't coming from the sandbox (if in production)
if (! empty($req['sandbox']) && $req['sandbox']) {
    echo 'Not in sandbox env'; exit();
}

// Webhook is legit! Perform actions on it
switch($req['name'])
{
case 'invoice.transaction.completed':
    // Transaction successful
    break;
case 'invoice.transaction.pending':
    // Transaction still needs some time to be processed
    break;
// ...
default:
    echo 'Unknown webhook action'; exit();
}
?>
```

```go
// Webhook is the definition of a ProcessOut webhook
type Webhook struct {
    Name        string                  `json:"name"`
    Sandbox     bool                    `json:"sandbox"`
    Invoice     *processout.Invoice     `json:"invoice"`
    Transaction *processout.Transaction `json:"transaction"`
    Customer    *processout.Customer    `json:"customer"`
}

func handleProcessOutWebhooks(w http.ResponseWriter,
	r *http.Request) {

	defer r.Body.Close()
	reqRaw, err := ioutil.ReadAll(r.Body)
	if err != nil {
		panic(err)
	}

	signature := r.Header.Get("HTTP_ProcessOut-Signature")

	// Check the webhook signature
	err = p.Webhooks.Validate(reqRaw, signature)
	if err != nil {
		// Signature check failed; webhook is not authenticated
		w.WriteHeader(http.StatusForbidden)
		return
	}

	// Decode the webhook
	webhook := &Webhook{}
	err = json.Unmarshal(reqRaw, &webhook)
	if err != nil {
		// Invalid webhook data
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Check that the webhook does not come from the sandbox
	// (disable this in development and staging)
	if webhook.Sandbox {
		w.WriteHeader(http.StatusForbidden)
		return
	}

	// Everything is okay, process the webhook
	switch webhook.Name {
	case "invoice.transaction.completed":
		// Successful transaction

	case "invoice.transaction.pending":
		// Transaction still needs some time to be processed

	// ...

	default:
		// Return an HTTP OK response so that unsuported
		// webhooks do not get sent again
		w.WriteHeader(http.StatusOK)
		return
	}
}
```

Now that your webhook is correctly set up, we need to make sure it is correctly
processed and authenticated by your application.

You should also make sure that when deployed on your production environment,
you do not accept sandbox webhooks anymore.

Once correctly processed by your application, you should always return a
`status 200 response`. If you don't, ProcessOut will try to send the webhook
again, waiting an increasing amount of time between each tries.
